<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Draw Client - Test ƒê·ªìng B·ªô V·∫Ω</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .status {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            margin-top: 10px;
        }

        .status.connected {
            background: #4caf50;
        }

        .status.disconnected {
            background: #f44336;
        }

        .status.connecting {
            background: #ff9800;
        }

        .login-panel {
            padding: 30px;
            text-align: center;
        }

        .login-panel input {
            padding: 12px;
            margin: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            width: 250px;
        }

        .login-panel button {
            padding: 12px 30px;
            margin: 10px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .login-panel button:hover {
            background: #5568d3;
        }

        .login-panel button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .drawing-area {
            display: none;
            padding: 20px;
        }

        .drawing-area.active {
            display: block;
        }

        .canvas-container {
            text-align: center;
            margin-bottom: 20px;
        }

        #drawCanvas {
            border: 3px solid #667eea;
            border-radius: 10px;
            cursor: crosshair;
            background: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-weight: bold;
            color: #333;
        }

        .control-group input[type="color"] {
            width: 60px;
            height: 40px;
            border: 2px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
        }

        .control-group input[type="range"] {
            width: 150px;
        }

        .control-group button {
            padding: 10px 20px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .control-group button:hover {
            background: #d32f2f;
        }

        .info-panel {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .info-panel h3 {
            margin-bottom: 10px;
            color: #667eea;
        }

        .info-panel p {
            margin: 5px 0;
            color: #666;
        }

        .log {
            background: #1e1e1e;
            color: #0f0;
            padding: 15px;
            border-radius: 5px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-top: 10px;
        }

        .log-entry {
            margin: 3px 0;
        }

        .log-entry.error {
            color: #f00;
        }

        .log-entry.success {
            color: #0f0;
        }

        .log-entry.info {
            color: #0ff;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé® Draw Client - Test ƒê·ªìng B·ªô V·∫Ω</h1>
            <div id="status" class="status disconnected">Ch∆∞a k·∫øt n·ªëi</div>
        </div>

        <div id="loginPanel" class="login-panel">
            <h2>ƒêƒÉng nh·∫≠p</h2>
            <div>
                <input type="text" id="username" placeholder="Username" value="testuser">
                <br>
                <input type="password" id="password" placeholder="Password" value="test123">
                <br>
                <input type="text" id="serverUrl" placeholder="WebSocket URL" value="ws://localhost:3000">
                <br>
                <button id="connectBtn" onclick="connect()">K·∫øt n·ªëi</button>
            </div>
        </div>

        <div id="drawingArea" class="drawing-area">
            <div class="canvas-container">
                <canvas id="drawCanvas" width="800" height="600"></canvas>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>M√†u:</label>
                    <input type="color" id="colorPicker" value="#000000">
                </div>
                <div class="control-group">
                    <label>ƒê·ªô r·ªông:</label>
                    <input type="range" id="brushSize" min="1" max="20" value="5">
                    <span id="brushSizeValue">5</span>
                </div>
                <div class="control-group">
                    <button id="eraserBtn" onclick="toggleEraser()">B√∫t x√≥a</button>
                </div>
                <div class="control-group">
                    <button onclick="clearCanvas()">X√≥a Canvas</button>
                </div>
            </div>

            <div class="info-panel">
                <h3>Th√¥ng tin</h3>
                <p><strong>Username:</strong> <span id="userInfo">-</span></p>
                <p><strong>Tr·∫°ng th√°i:</strong> <span id="drawStatus">S·∫µn s√†ng v·∫Ω</span></p>
                <p><strong>Th√¥ng b√°o:</strong> <span id="message">M·ªü nhi·ªÅu tab ƒë·ªÉ test ƒë·ªìng b·ªô!</span></p>
                
                <div class="log" id="log">
                    <div class="log-entry info">Nh·∫≠t k√Ω s·ª± ki·ªán...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let ws = null;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let canvas, ctx;
        let currentColor = '#000000';
        let brushSize = 5;
        let username = '';
        let isEraserMode = false;

        // Kh·ªüi t·∫°o canvas
        window.onload = function() {
            canvas = document.getElementById('drawCanvas');
            ctx = canvas.getContext('2d');
            
            // Setup canvas drawing
            setupCanvas();
            
            // Setup controls
            document.getElementById('colorPicker').addEventListener('change', (e) => {
                currentColor = e.target.value;
            });
            
            document.getElementById('brushSize').addEventListener('input', (e) => {
                brushSize = parseInt(e.target.value);
                document.getElementById('brushSizeValue').textContent = brushSize;
            });
        };

        function setupCanvas() {
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
        }

        function startDrawing(e) {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;
        }

        function draw(e) {
            if (!isDrawing) return;

            const rect = canvas.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;

            // V·∫Ω tr√™n canvas local
            if (isEraserMode) {
                // Ch·∫ø ƒë·ªô x√≥a: d√πng destination-out
                ctx.globalCompositeOperation = 'destination-out';
            } else {
                // Ch·∫ø ƒë·ªô v·∫Ω b√¨nh th∆∞·ªùng
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = currentColor;
            }
            
            ctx.lineWidth = brushSize;
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(currentX, currentY);
            ctx.stroke();

            // G·ª≠i draw data ƒë·∫øn server
            sendDrawData(lastX, lastY, currentX, currentY);

            lastX = currentX;
            lastY = currentY;
        }

        function stopDrawing() {
            isDrawing = false;
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            sendClearAction();
        }

        function toggleEraser() {
            isEraserMode = !isEraserMode;
            const eraserBtn = document.getElementById('eraserBtn');
            if (isEraserMode) {
                eraserBtn.textContent = 'B√∫t v·∫Ω';
                eraserBtn.style.background = '#4caf50';
                addLog('ƒê√£ b·∫≠t ch·∫ø ƒë·ªô b√∫t x√≥a', 'info');
            } else {
                eraserBtn.textContent = 'B√∫t x√≥a';
                eraserBtn.style.background = '';
                addLog('ƒê√£ t·∫Øt ch·∫ø ƒë·ªô b√∫t x√≥a', 'info');
            }
        }

        // Chuy·ªÉn ƒë·ªïi m√†u hex sang RGBA integer
        function hexToRGBA(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            const a = 255;
            return (r << 24) | (g << 16) | (b << 8) | a;
        }

        // G·ª≠i DRAW_DATA ƒë·∫øn server
        function sendDrawData(x1, y1, x2, y2) {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;

            const action = isEraserMode ? 3 : 1; // DRAW_ACTION_ERASE ho·∫∑c DRAW_ACTION_LINE
            const color = isEraserMode ? 0 : hexToRGBA(currentColor); // Color kh√¥ng quan tr·ªçng v·ªõi ERASE
            
            // T·∫°o payload theo format: [action:1][x1:2][y1:2][x2:2][y2:2][color:4][width:1] = 14 bytes
            const buffer = new ArrayBuffer(14);
            const view = new DataView(buffer);
            
            view.setUint8(0, action);
            view.setUint16(1, Math.round(x1), false); // Big-endian
            view.setUint16(3, Math.round(y1), false);
            view.setUint16(5, Math.round(x2), false);
            view.setUint16(7, Math.round(y2), false);
            view.setUint32(9, color, false); // Big-endian
            view.setUint8(13, brushSize);

            // T·∫°o message: [TYPE:1][LENGTH:2][PAYLOAD:14]
            const messageBuffer = new ArrayBuffer(17);
            const messageView = new DataView(messageBuffer);
            
            messageView.setUint8(0, 0x22); // MSG_DRAW_DATA
            messageView.setUint16(1, 14, false); // Payload length (big-endian)
            
            const payload = new Uint8Array(buffer);
            const message = new Uint8Array(messageBuffer);
            message.set(payload, 3);

            ws.send(message.buffer);
            addLog('ƒê√£ g·ª≠i DRAW_DATA', 'info');
        }

        // G·ª≠i CLEAR action
        function sendClearAction() {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;

            const action = 2; // DRAW_ACTION_CLEAR
            
            const buffer = new ArrayBuffer(14);
            const view = new DataView(buffer);
            view.setUint8(0, action);
            // C√°c bytes c√≤n l·∫°i = 0

            const messageBuffer = new ArrayBuffer(17);
            const messageView = new DataView(messageBuffer);
            
            messageView.setUint8(0, 0x22); // MSG_DRAW_DATA
            messageView.setUint16(1, 14, false);
            
            const payload = new Uint8Array(buffer);
            const message = new Uint8Array(messageBuffer);
            message.set(payload, 3);

            ws.send(message.buffer);
            addLog('ƒê√£ g·ª≠i CLEAR', 'info');
        }

        // K·∫øt n·ªëi WebSocket
        function connect() {
            console.log('connect() called');
            
            // Ki·ªÉm tra n·∫øu ƒë√£ k·∫øt n·ªëi, ƒë√≥ng k·∫øt n·ªëi c≈©
            if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
                console.log('ƒê√≥ng k·∫øt n·ªëi c≈©...');
                ws.close();
            }
            
            const serverUrl = document.getElementById('serverUrl').value;
            username = document.getElementById('username').value;
            const password = document.getElementById('password').value;

            if (!username || !password) {
                alert('Vui l√≤ng nh·∫≠p username v√† password!');
                return;
            }

            if (!serverUrl || (!serverUrl.startsWith('ws://') && !serverUrl.startsWith('wss://'))) {
                alert('Vui l√≤ng nh·∫≠p WebSocket URL h·ª£p l·ªá (b·∫Øt ƒë·∫ßu b·∫±ng ws:// ho·∫∑c wss://)');
                return;
            }

            updateStatus('connecting', 'ƒêang k·∫øt n·ªëi...');
            const connectBtn = document.getElementById('connectBtn');
            if (connectBtn) {
                connectBtn.disabled = true;
                connectBtn.textContent = 'ƒêang k·∫øt n·ªëi...';
            }

            // K·∫øt n·ªëi WebSocket
            ws = new WebSocket(serverUrl);

            ws.onopen = function() {
                addLog('ƒê√£ k·∫øt n·ªëi WebSocket', 'success');
                updateStatus('connected', 'ƒê√£ k·∫øt n·ªëi');
                
                // G·ª≠i login request
                sendLogin(username, password);
            };

            ws.onmessage = function(event) {
                console.log('WebSocket message received:', event.data);
                
                // T√≠nh to√°n size ƒë√∫ng c√°ch d·ª±a tr√™n ki·ªÉu d·ªØ li·ªáu
                let dataSize = 0;
                if (event.data instanceof Blob) {
                    dataSize = event.data.size;
                    console.log('Received Blob, size:', dataSize);
                    addLog(`Nh·∫≠n data t·ª´ server: ${dataSize} bytes (Blob)`, 'info');
                    
                    // Convert Blob sang ArrayBuffer
                    event.data.arrayBuffer().then(buffer => {
                        console.log('Converted to ArrayBuffer, size:', buffer.byteLength);
                        handleMessage(buffer);
                    }).catch(err => {
                        console.error('Error converting Blob:', err);
                        addLog('L·ªói convert Blob: ' + err.message, 'error');
                    });
                    return;
                } else if (event.data instanceof ArrayBuffer) {
                    dataSize = event.data.byteLength;
                    console.log('Received ArrayBuffer, size:', dataSize);
                    addLog(`Nh·∫≠n data t·ª´ server: ${dataSize} bytes`, 'info');
                } else if (typeof event.data === 'string') {
                    dataSize = event.data.length;
                    addLog(`Nh·∫≠n data t·ª´ server: ${dataSize} bytes (String)`, 'info');
                } else {
                    // Fallback
                    dataSize = event.data.byteLength || event.data.length || 0;
                    addLog(`Nh·∫≠n data t·ª´ server: ${dataSize} bytes`, 'info');
                }
                
                handleMessage(event.data);
            };

            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
                addLog('L·ªói WebSocket', 'error');
                updateStatus('disconnected', 'L·ªói k·∫øt n·ªëi');
                const connectBtn = document.getElementById('connectBtn');
                if (connectBtn) {
                    connectBtn.disabled = false;
                    connectBtn.textContent = 'K·∫øt n·ªëi';
                }
            };

            ws.onclose = function(event) {
                addLog(`ƒê√£ ƒë√≥ng k·∫øt n·ªëi (code: ${event.code}, reason: ${event.reason || 'none'})`, 'error');
                updateStatus('disconnected', 'ƒê√£ ng·∫Øt k·∫øt n·ªëi');
                const connectBtn = document.getElementById('connectBtn');
                if (connectBtn) {
                    connectBtn.disabled = false;
                    connectBtn.textContent = 'K·∫øt n·ªëi';
                }
                document.getElementById('drawingArea').classList.remove('active');
            };
        }

        // G·ª≠i login request
        function sendLogin(username, password) {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;

            // T·∫°o login payload: username(32) + password(32) = 64 bytes
            const buffer = new ArrayBuffer(64);
            const view = new DataView(buffer);
            
            // Write username (32 bytes)
            const usernameBytes = new TextEncoder().encode(username);
            for (let i = 0; i < Math.min(32, usernameBytes.length); i++) {
                view.setUint8(i, usernameBytes[i]);
            }
            
            // Write password (32 bytes, starting at offset 32)
            const passwordBytes = new TextEncoder().encode(password);
            for (let i = 0; i < Math.min(32, passwordBytes.length); i++) {
                view.setUint8(32 + i, passwordBytes[i]);
            }

            // T·∫°o message: [TYPE:1][LENGTH:2][PAYLOAD:64]
            const messageBuffer = new ArrayBuffer(67);
            const messageView = new DataView(messageBuffer);
            
            messageView.setUint8(0, 0x01); // MSG_LOGIN_REQUEST
            messageView.setUint16(1, 64, false); // Payload length (big-endian)
            
            const payload = new Uint8Array(buffer);
            const message = new Uint8Array(messageBuffer);
            message.set(payload, 3);

            ws.send(message.buffer);
            addLog('ƒê√£ g·ª≠i LOGIN_REQUEST', 'info');
        }

        // X·ª≠ l√Ω message t·ª´ server
        function handleMessage(data) {
            if (data instanceof ArrayBuffer) {
                const view = new DataView(data);
                
                if (data.byteLength < 3) {
                    addLog('Message qu√° ng·∫Øn', 'error');
                    return;
                }

                const type = view.getUint8(0);
                const length = view.getUint16(1, false); // Big-endian

                addLog(`Nh·∫≠n message: type=0x${type.toString(16)}, length=${length}, total=${data.byteLength}`, 'info');

                if (data.byteLength < 3 + length) {
                    addLog(`Message kh√¥ng ƒë·∫ßy ƒë·ªß: c√≥ ${data.byteLength} bytes, c·∫ßn ${3 + length} bytes`, 'error');
                    return;
                }

                const payload = new Uint8Array(data, 3, length);

                switch (type) {
                    case 0x02: // MSG_LOGIN_RESPONSE
                        addLog('X·ª≠ l√Ω LOGIN_RESPONSE...', 'info');
                        handleLoginResponse(payload);
                        break;
                    case 0x11: // MSG_ROOM_LIST_RESPONSE
                        addLog('X·ª≠ l√Ω ROOM_LIST_RESPONSE...', 'info');
                        handleRoomListResponse(payload);
                        break;
                    case 0x12: // MSG_CREATE_ROOM (response)
                        addLog('X·ª≠ l√Ω CREATE_ROOM_RESPONSE...', 'info');
                        handleCreateRoomResponse(payload);
                        break;
                    case 0x13: // MSG_JOIN_ROOM (response)
                        addLog('X·ª≠ l√Ω JOIN_ROOM_RESPONSE...', 'info');
                        handleJoinRoomResponse(payload);
                        break;
                    case 0x15: // MSG_ROOM_UPDATE
                        addLog('X·ª≠ l√Ω ROOM_UPDATE...', 'info');
                        handleRoomUpdate(payload);
                        break;
                    case 0x23: // MSG_DRAW_BROADCAST
                        handleDrawBroadcast(payload);
                        break;
                    default:
                        addLog(`Nh·∫≠n message type: 0x${type.toString(16)} (ch∆∞a x·ª≠ l√Ω)`, 'info');
                }
            } else {
                addLog('Nh·∫≠n message kh√¥ng ph·∫£i ArrayBuffer', 'error');
            }
        }

        // X·ª≠ l√Ω LOGIN_RESPONSE
        function handleLoginResponse(payload) {
            console.log('handleLoginResponse called, payload:', payload);
            addLog(`Nh·∫≠n LOGIN_RESPONSE, payload length: ${payload.length}`, 'info');
            
            if (payload.length < 37) { // status(1) + user_id(4) + username(32) = 37 bytes
                addLog(`Payload qu√° ng·∫Øn: ${payload.length} bytes, c·∫ßn √≠t nh·∫•t 37 bytes`, 'error');
                console.error('Payload too short:', payload.length);
                return;
            }
            
            try {
                const view = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
                const status = view.getUint8(0);
                
                // Parse user_id (signed int32, big-endian)
                // Server g·ª≠i: htonl((uint32_t)user_id) - convert signed int32 to network byte order
                // C·∫ßn ƒë·ªçc nh∆∞ uint32 r·ªìi convert v·ªÅ int32
                const userIdRaw = view.getUint32(1, false); // Big-endian, read as unsigned
                // Convert unsigned to signed int32 (two's complement)
                let userId = userIdRaw;
                if (userIdRaw >= 0x80000000) {
                    userId = userIdRaw - 0x100000000;
                }
                
                // Parse username (32 bytes, starting at offset 5)
                const usernameBytes = new Uint8Array(payload.buffer, payload.byteOffset + 5, 32);
                let usernameStr = '';
                for (let i = 0; i < 32; i++) {
                    if (usernameBytes[i] === 0) break;
                    usernameStr += String.fromCharCode(usernameBytes[i]);
                }
                
                console.log('Parsed LOGIN_RESPONSE:', { status, userId, userIdRaw, usernameStr });
                addLog(`Status: ${status}, User ID: ${userId}, Username: ${usernameStr}`, 'info');
                
                // X·ª≠ l√Ω k·∫øt qu·∫£ ƒëƒÉng nh·∫≠p
                if (status === 0) { // STATUS_SUCCESS
                    addLog(`ƒêƒÉng nh·∫≠p th√†nh c√¥ng! User ID: ${userId}`, 'success');
                    console.log('ƒêƒÉng nh·∫≠p th√†nh c√¥ng, b·∫Øt ƒë·∫ßu t·ª± ƒë·ªông t·∫°o/join ph√≤ng...');
                    
                    // L∆∞u user_id ƒë·ªÉ d√πng sau
                    window.currentUserId = userId;
                    
                    // T·ª± ƒë·ªông y√™u c·∫ßu danh s√°ch ph√≤ng ƒë·ªÉ ki·ªÉm tra
                    sendRoomListRequest();
                } else {
                    addLog(`ƒêƒÉng nh·∫≠p th·∫•t b·∫°i (status: ${status})`, 'error');
                    updateStatus('disconnected', 'ƒêƒÉng nh·∫≠p th·∫•t b·∫°i');
                    const connectBtn = document.getElementById('connectBtn');
                    if (connectBtn) {
                        connectBtn.disabled = false;
                        connectBtn.textContent = 'K·∫øt n·ªëi';
                    }
                }
            } catch (error) {
                addLog(`L·ªói parse LOGIN_RESPONSE: ${error.message}`, 'error');
                console.error('Parse error:', error);
                return;
            }
        }

        // G·ª≠i ROOM_LIST_REQUEST
        function sendRoomListRequest() {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            
            const messageBuffer = new ArrayBuffer(3);
            const messageView = new DataView(messageBuffer);
            messageView.setUint8(0, 0x10); // MSG_ROOM_LIST_REQUEST
            messageView.setUint16(1, 0, false); // Payload length = 0
            
            ws.send(messageBuffer);
            addLog('ƒê√£ g·ª≠i ROOM_LIST_REQUEST', 'info');
        }

        // G·ª≠i CREATE_ROOM request
        function sendCreateRoom(roomName, maxPlayers, rounds) {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            
            // Payload: room_name(32) + max_players(1) + rounds(1) = 34 bytes
            const buffer = new ArrayBuffer(34);
            const view = new DataView(buffer);
            
            // Write room_name (32 bytes)
            const nameBytes = new TextEncoder().encode(roomName);
            for (let i = 0; i < Math.min(32, nameBytes.length); i++) {
                view.setUint8(i, nameBytes[i]);
            }
            
            view.setUint8(32, maxPlayers);
            view.setUint8(33, rounds);
            
            // T·∫°o message
            const messageBuffer = new ArrayBuffer(37);
            const messageView = new DataView(messageBuffer);
            messageView.setUint8(0, 0x12); // MSG_CREATE_ROOM
            messageView.setUint16(1, 34, false);
            
            const payload = new Uint8Array(buffer);
            const message = new Uint8Array(messageBuffer);
            message.set(payload, 3);
            
            ws.send(message.buffer);
            addLog(`ƒê√£ g·ª≠i CREATE_ROOM: ${roomName}`, 'info');
        }

        // G·ª≠i JOIN_ROOM request
        function sendJoinRoom(roomId) {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            
            // Payload: room_id(4) = 4 bytes
            const buffer = new ArrayBuffer(4);
            const view = new DataView(buffer);
            view.setUint32(0, roomId, false); // Big-endian
            
            // T·∫°o message
            const messageBuffer = new ArrayBuffer(7);
            const messageView = new DataView(messageBuffer);
            messageView.setUint8(0, 0x13); // MSG_JOIN_ROOM
            messageView.setUint16(1, 4, false);
            
            const payload = new Uint8Array(buffer);
            const message = new Uint8Array(messageBuffer);
            message.set(payload, 3);
            
            ws.send(message.buffer);
            addLog(`ƒê√£ g·ª≠i JOIN_ROOM: room_id=${roomId}`, 'info');
        }

        // G·ª≠i START_GAME request
        function sendStartGame() {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            
            // START_GAME kh√¥ng c√≥ payload
            const messageBuffer = new ArrayBuffer(3);
            const messageView = new DataView(messageBuffer);
            messageView.setUint8(0, 0x16); // MSG_START_GAME
            messageView.setUint16(1, 0, false); // Payload length = 0
            
            ws.send(messageBuffer);
            addLog('ƒê√£ g·ª≠i START_GAME', 'info');
        }

        // X·ª≠ l√Ω ROOM_LIST_RESPONSE
        function handleRoomListResponse(payload) {
            if (payload.length < 2) {
                addLog('ROOM_LIST_RESPONSE payload qu√° ng·∫Øn', 'error');
                return;
            }
            
            const view = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
            const roomCount = view.getUint16(0, false); // Big-endian
            
            console.log('Nh·∫≠n ROOM_LIST_RESPONSE, s·ªë ph√≤ng:', roomCount);
            addLog(`C√≥ ${roomCount} ph√≤ng`, 'info');
            
            if (roomCount === 0) {
                // Kh√¥ng c√≥ ph√≤ng, t·∫°o ph√≤ng m·ªõi
                addLog('Kh√¥ng c√≥ ph√≤ng, t·∫°o ph√≤ng m·ªõi "Ph√≤ng 1"', 'info');
                sendCreateRoom("Ph√≤ng 1", 2, 2); // 2 ng∆∞·ªùi ch∆°i, 2 v√≤ng
            } else {
                // C√≥ ph√≤ng, join v√†o ph√≤ng ƒë·∫ßu ti√™n (room_id = 1)
                addLog('T√¨m th·∫•y ph√≤ng, join v√†o ph√≤ng 1', 'info');
                sendJoinRoom(1);
            }
        }

        // X·ª≠ l√Ω CREATE_ROOM_RESPONSE
        function handleCreateRoomResponse(payload) {
            if (payload.length < 133) { // status(1) + room_id(4) + message(128) = 133
                addLog('CREATE_ROOM_RESPONSE payload qu√° ng·∫Øn', 'error');
                return;
            }
            
            const view = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
            const status = view.getUint8(0);
            const roomIdRaw = view.getUint32(1, false);
            let roomId = roomIdRaw;
            if (roomIdRaw >= 0x80000000) {
                roomId = roomIdRaw - 0x100000000;
            }
            
            if (status === 0) {
                addLog(`T·∫°o ph√≤ng th√†nh c√¥ng! Room ID: ${roomId}`, 'success');
                window.currentRoomId = roomId;
                // Ch·ªù ROOM_UPDATE ƒë·ªÉ bi·∫øt khi c√≥ ng∆∞·ªùi join v√† t·ª± ƒë·ªông start game
                addLog('ƒêang ch·ªù ng∆∞·ªùi ch∆°i kh√°c...', 'info');
            } else {
                addLog(`T·∫°o ph√≤ng th·∫•t b·∫°i (status: ${status})`, 'error');
            }
        }

        // X·ª≠ l√Ω JOIN_ROOM_RESPONSE
        function handleJoinRoomResponse(payload) {
            if (payload.length < 133) { // status(1) + room_id(4) + message(128) = 133
                addLog('JOIN_ROOM_RESPONSE payload qu√° ng·∫Øn', 'error');
                return;
            }
            
            const view = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
            const status = view.getUint8(0);
            const roomIdRaw = view.getUint32(1, false);
            let roomId = roomIdRaw;
            if (roomIdRaw >= 0x80000000) {
                roomId = roomIdRaw - 0x100000000;
            }
            
            if (status === 0) {
                addLog(`Join ph√≤ng th√†nh c√¥ng! Room ID: ${roomId}`, 'success');
                window.currentRoomId = roomId;
                // Ch·ªù ROOM_UPDATE ƒë·ªÉ bi·∫øt s·ªë ng∆∞·ªùi ch∆°i v√† t·ª± ƒë·ªông start game
            } else {
                addLog(`Join ph√≤ng th·∫•t b·∫°i (status: ${status})`, 'error');
            }
        }

        // X·ª≠ l√Ω ROOM_UPDATE
        function handleRoomUpdate(payload) {
            if (payload.length < 43) { // room_id(4) + room_name(32) + player_count(1) + max_players(1) + state(1) + owner_id(4) = 43
                addLog('ROOM_UPDATE payload qu√° ng·∫Øn', 'error');
                return;
            }
            
            const view = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
            const roomIdRaw = view.getUint32(0, false);
            let roomId = roomIdRaw;
            if (roomIdRaw >= 0x80000000) {
                roomId = roomIdRaw - 0x100000000;
            }
            
            // Parse room_name (32 bytes, starting at offset 4)
            const nameBytes = new Uint8Array(payload.buffer, payload.byteOffset + 4, 32);
            let roomName = '';
            for (let i = 0; i < 32; i++) {
                if (nameBytes[i] === 0) break;
                roomName += String.fromCharCode(nameBytes[i]);
            }
            
            const playerCount = view.getUint8(36);
            const maxPlayers = view.getUint8(37);
            const state = view.getUint8(38);
            
            console.log('ROOM_UPDATE:', { roomId, roomName, playerCount, maxPlayers, state });
            addLog(`Ph√≤ng ${roomName}: ${playerCount}/${maxPlayers} ng∆∞·ªùi ch∆°i (state=${state})`, 'info');
            
            // N·∫øu ph√≤ng c√≥ 2 ng∆∞·ªùi v√† ƒëang WAITING, t·ª± ƒë·ªông start game
            if (playerCount >= 2 && state === 0) { // ROOM_WAITING = 0
                addLog('Ph√≤ng ƒë√£ c√≥ 2 ng∆∞·ªùi, t·ª± ƒë·ªông b·∫Øt ƒë·∫ßu game...', 'info');
                setTimeout(() => {
                    sendStartGame();
                }, 500);
            }
            
            // N·∫øu ph√≤ng ƒë√£ PLAYING, chuy·ªÉn sang trang v·∫Ω
            if (state === 1) { // ROOM_PLAYING = 1
                if (!window.isInDrawingArea) {
                    showDrawingArea();
                }
            }
        }

        // Hi·ªÉn th·ªã drawing area
        function showDrawingArea() {
            window.isInDrawingArea = true;
            addLog('Chuy·ªÉn sang trang v·∫Ω...', 'success');
            
            // ·∫®n login panel
            const loginPanel = document.getElementById('loginPanel');
            if (loginPanel) {
                loginPanel.style.display = 'none';
            }
            
            // Hi·ªán drawing area
            const drawingArea = document.getElementById('drawingArea');
            if (drawingArea) {
                drawingArea.classList.add('active');
            }
            
            // C·∫≠p nh·∫≠t th√¥ng tin
            const userInfoEl = document.getElementById('userInfo');
            if (userInfoEl) {
                userInfoEl.textContent = username;
            }
            
            const drawStatusEl = document.getElementById('drawStatus');
            if (drawStatusEl) {
                drawStatusEl.textContent = 'ƒê√£ v√†o ph√≤ng - S·∫µn s√†ng v·∫Ω';
            }
            
            const connectBtn = document.getElementById('connectBtn');
            if (connectBtn) {
                connectBtn.disabled = false;
                connectBtn.textContent = 'K·∫øt n·ªëi';
            }
        }

        // X·ª≠ l√Ω DRAW_BROADCAST
        function handleDrawBroadcast(payload) {
            if (payload.length < 14) {
                addLog('DRAW_BROADCAST payload kh√¥ng h·ª£p l·ªá', 'error');
                return;
            }

            const view = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
            const action = view.getUint8(0);
            
            if (action === 2) { // CLEAR
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                addLog('Nh·∫≠n CLEAR t·ª´ server', 'info');
                return;
            }

            if (action === 1) { // LINE
                const x1 = view.getUint16(1, false); // Big-endian
                const y1 = view.getUint16(3, false);
                const x2 = view.getUint16(5, false);
                const y2 = view.getUint16(7, false);
                const colorInt = view.getUint32(9, false);
                const width = view.getUint8(13);

                // Chuy·ªÉn ƒë·ªïi color t·ª´ integer sang hex
                const r = (colorInt >>> 24) & 0xFF;
                const g = (colorInt >>> 16) & 0xFF;
                const b = (colorInt >>> 8) & 0xFF;
                const color = `rgb(${r},${g},${b})`;

                // V·∫Ω tr√™n canvas
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = color;
                ctx.lineWidth = width;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();

                addLog(`Nh·∫≠n DRAW_BROADCAST: (${x1},${y1}) -> (${x2},${y2})`, 'info');
            }

            if (action === 3) { // ERASE
                const x1 = view.getUint16(1, false); // Big-endian
                const y1 = view.getUint16(3, false);
                const x2 = view.getUint16(5, false);
                const y2 = view.getUint16(7, false);
                const width = view.getUint8(13);

                // X√≥a tr√™n canvas b·∫±ng destination-out
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = width;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();

                addLog(`Nh·∫≠n ERASE_BROADCAST: (${x1},${y1}) -> (${x2},${y2})`, 'info');
            }
        }

        // C·∫≠p nh·∫≠t tr·∫°ng th√°i
        function updateStatus(status, text) {
            const statusEl = document.getElementById('status');
            statusEl.className = 'status ' + status;
            statusEl.textContent = text;
        }

        // Th√™m log
        function addLog(message, type = 'info') {
            const log = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = 'log-entry ' + type;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }
    </script>
</body>
</html>

